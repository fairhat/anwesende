#!/bin/bash

# ########## constants:

ENVSDIR=.envs
ENVSSRCDIR=config/envs
TRAEFIK_YML=compose/production/traefik/traefik.yml
DOCKER_COMPOSE_YML=docker-compose.yml
DOCKERENV_ENV=$ENVSDIR/autogenerated.env
MYENV_ENV=$ENVSDIR/myenv.env

# image names are hardcoded, see make_docker_compose_yml and transfer_images


# ########## usage:

if [ $# -lt 2 ]; then 
  cat <<ENDOFFILE
anw env cmd args...
  env  reads environment variables from $ENVSDIR/{env}.sh
  cmd  is a command defined in the anw script (list them with 'anw - help')
  args are cmd-dependent arguments, most often none
  When needed, the commands will read the files 
    ${MYENV_ENV} and $ENVSDIR/{env}
  and use the settings therein to generate the following files on the fly:
    $DOCKER_COMPOSE_YML  (which configures docker)
    $DOCKERENV_ENV  (used to hand environment into the docker containers)
    $TRAEFIK_YML  (for deploymodes LETSENCRYPT and CERTS only)
ENDOFFILE
  exit 1
fi

# ########## individual command functions (externally visible):

help()   # args: 
{
  echo "########## anw commands:"
  egrep '\(\) *[#] args:' $0 | sed 's/() *[#] args:/ /'  # (must not match itself)
  cat <<ENDOFFILE
  ## Abbreviations:
  dc      docker-compose
  th      target host (the server)
  dev     development machine (the server or some other)
ENDOFFILE
}

prepare_envs()   # args:
{
  announce $FUNCNAME
  mkdir -p $ENVSDIR
  cp -u $ENVSSRCDIR/myenv-template.env $ENVSDIR/myenv.env
  cp -u $ENVSSRCDIR/production-template.sh $ENVSDIR/production.sh
}

docker_login()   # args:
{
  announce $FUNCNAME
  docker login -u ${REGISTRYUSER} ${REGISTRY}
  ssh -t $TUTH docker login -u ${REGISTRYUSER} ${REGISTRY}
}

install()   # args: 
{
  announce $FUNCNAME
  build_images
  transfer_images
  transfer_env
  deploy
}

build_images()   # args: 
{
  announce $FUNCNAME
  
}

transfer_images()   # args: 
{
  announce $FUNCNAME
  if [ ! $REGISTRY ]; then
    return  # no transfer needed: build has occured right on the server
  fi
  #  image: anw_${ENV_SHORTNAME}_postgres

	docker tag anw_${ENV_SHORTNAME}_django $(REGISTRYPREFIX)/anw_${ENV_SHORTNAME}_django
	docker tag anw_${ENV_SHORTNAME}_postgres $(REGISTRYPREFIX)/anw_${ENV_SHORTNAME}_postgres
	docker tag anw_${ENV_SHORTNAME}_traefik $(REGISTRYPREFIX)/anw_${ENV_SHORTNAME}_traefik

	# don't forget to k_d_login before
	docker push $(REGISTRYPREFIX)/staging_django
	docker push $(REGISTRYPREFIX)/staging_postgres
	docker push $(REGISTRYPREFIX)/staging_traefik

	docker pull $(REGISTRYPREFIX)/staging_django
	docker pull $(REGISTRYPREFIX)/staging_postgres
	docker pull $(REGISTRYPREFIX)/staging_traefik

}

transfer_env()   # args: 
{
  announce $FUNCNAME
}

server_up()   # args: 
{
  announce $FUNCNAME
}

server_down()   # args: 
{
  announce $FUNCNAME
}


# ########## individual command functions (internal):

announce()  # internal
{
  echo ""
  echo "########## $1"
}

make_docker_compose_yml()  # internal, assumes env has been read already
{
  # ugly function due to inline documents violating the indentation
  announce $FUNCNAME
  cat >$DOCKER_COMPOSE_YML <<ENDOFFILE1
version: '2'
 https://docs.docker.com/compose/compose-file/

services:
  django:
    build:
      context: .
      dockerfile: ./compose/production/django/Dockerfile
    image: anw_${ENV_SHORTNAME}_django
    env_file: $DOCKERENV_ENV
    volumes:
      - ${VOLUME_SERVERDIR_DJANGO_LOG}:/djangolog:Z
    depends_on:
      - postgres
ENDOFFILE1
  if [ $DEPLOYMODE == GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE2
    ports:
      - "0.0.0.0:${GUNICORN_PORT}:5000"
ENDOFFILE2
  fi
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE3
    command: /start

  postgres:
    build:
      context: .
      dockerfile: ./compose/production/postgres/Dockerfile
    image: anw_${ENV_SHORTNAME}_postgres
    env_file: $DOCKERENV_ENV
    volumes:
      - ${VOLUME_SERVERDIR_POSTGRES_DATA}:/var/lib/postgresql/data:Z
      - ${VOLUME_SERVERDIR_POSTGRES_BACKUP}:/backups:z

ENDOFFILE3
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE4
  traefik:
    build:
      context: .
      dockerfile: ./compose/production/traefik/Dockerfile
    image: anw_${ENV_SHORTNAME}_traefik
    env_file: $DOCKERENV_ENV
    depends_on:
      - django
    volumes:
ENDOFFILE4
   fi
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE5
      - ${VOLUME_SERVERDIR_TRAEFIK_ACME}:/etc/traefik/acme:z
ENDOFFILE5
  fi
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE6
      - ${VOLUME_SERVERDIR_TRAEFIK_SSL}:/etc/traefik/myssl:z
ENDOFFILE6
  fi
  cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE7
    ports:
      - "0.0.0.0:${TRAEFIK_HTTP_PORT}:80"
      - "0.0.0.0:${TRAEFIK_HTTPS_PORT}:443"
ENDOFFILE7
}  # END make_docker_compose_yml

make_dockerenv_env()  # internal, assumes env has been read already
{
  announce $FUNCNAME
  python3 $PATCHENV $MYENV_ENV >$DOCKERENV_ENV
}

make_traefik_yml()  # internal, assumes env has been read already
{
  # ugly function due to inline documents violating the indentation
  announce $FUNCNAME
  cat >$TRAEFIK_YML <<ENDOFFILE1
# https://doc.traefik.io/traefik/v2.0/providers/file/
# Quote: "Go Templating only works with dedicated dynamic configuration files.
#         Templating does not work in the Traefik main static configuration file."
log:
  level: INFO

entryPoints:
  web:
    # http
    address: ":80"

  web-secure:
    # https
    address: ":443"

ENDOFFILE1
  if [ $DEPLOYMODE == LETSENCRYPT ]; then
      cat >>$TRAEFIK_YML <<ENDOFFILE2
certificatesResolvers:
  letsencrypt:
    # https://docs.traefik.io/master/https/acme/#lets-encrypt
    acme:
      email: "techexpert@here-at-example.com"
      storage: /etc/traefik/acme/acme.json
      # https://docs.traefik.io/master/https/acme/#httpchallenge
      httpChallenge:
        entryPoint: web
ENDOFFILE2
  fi
  cat >>$TRAEFIK_YML <<ENDOFFILE3
http:
  routers:
    web-router:
      rule: "PathPrefix(`/`)"
      entryPoints:
        - web
      middlewares:
        - redirect_root
        - redirect_a
        - redirect_fu
        - redirect_to_https
      service: django

    web-secure-router:
      # https://doc.traefik.io/traefik/routing/routers/#rule
      rule: "PathPrefix(`/`)"
      entryPoints:
        - web-secure
      # middlewares:
      #   - csrf
      service: django
      tls: {}

  middlewares:
    # https://doc.traefik.io/traefik/master/middlewares/overview/
    redirect_root:
      # https://doc.traefik.io/traefik/v2.0/middlewares/redirectregex/
      redirectRegex:
        regex: "^http://a.nwesen.de/?$"
        replacement: "http://anwesende.imp.fu-berlin.de/"
    redirect_a:
      redirectRegex:
        regex: "^http://a.nwesen.de/a/(.*)$"
        replacement: "http://anwesende.imp.fu-berlin.de/${1}"
    redirect_fu:
      redirectRegex:
        regex: "^http://a.nwesen.de/fu/(.*)$"
        replacement: "http://anwesende.imp.fu-berlin.de/${1}"
    redirect_to_https:
      # https://docs.traefik.io/master/middlewares/redirectscheme/
      redirectScheme:
        scheme: https
        permanent: false

  services:
    django:
      loadBalancer:
        servers:
          - url: http://django:5000
ENDOFFILE3
  if [ $DEPLOYMODE == LETSENCRYPT ]; then
    cat >>$TRAEFIK_YML <<ENDOFFILE4
tls:
  # https://docs.traefik.io/master/routing/routers/#certresolver
  certResolver: letsencrypt
ENDOFFILE4
  fi
  if [ $DEPLOYMODE == CERTS ]; then
    cat >>$TRAEFIK_YML <<ENDOFFILE5
tls:
  # https://docs.traefik.io/master/routing/routers/#certresolver
  certificates:
    - certFile: /etc/traefik/myssl/anwesende.pem
      keyFile: /etc/traefik/myssl/anwesende-key.pem
ENDOFFILE5
  fi
  cat >>$TRAEFIK_YML <<ENDOFFILE6
  options:
    default:
      minVersion: VersionTLS12
      cipherSuites:
        # https://ssl-config.mozilla.org/#server=traefik&version=2.1.2&config=intermediate&guideline=5.6
        # https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices#25-use-forward-secrecy
        - "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"
        - "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"
        - "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305"
        - "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
        - "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
        - "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305"

providers:
  # https://docs.traefik.io/master/providers/file/
  file:
    filename: /etc/traefik/traefik.yml
    watch: true

ENDOFFILE6
}  # END make_traefik_yml

ssh_th()  # internal, assumes env has been read already
{
  command="ssh $TUTH $*"
  echo $command
  $command
}

# ########## MAIN:

set -x
which_env=$1
cmd=$2
shift 2

set -a  # export all new shell variables
if [ $which_env != '-' ]; then
  source $ENVSDIR/$which_env.sh
fi

announce "Environment is \'$which_env\'"
$cmd
