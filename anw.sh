#!/bin/bash
# Install script for 'anwesende'.

# ########## constants:

ANW=anw  # shorter form of 'anwesende'
ENVSDIR=.envs
ENVSSRCDIR=config/envs
TRAEFIK_YML=compose/production/traefik/traefik.yml
DOCKER_COMPOSE_YML=docker-compose.yml
DOCKERENV_ENV=$ENVSDIR/autogenerated.env
MYENV_ENV=$ENVSDIR/myenv.env
PATCHENV=config/envs/patch_env.py

onserver_anw="ssh -t $TUTH \~/${ANW}/anw.sh"

# image names are hardcoded, see make_docker_compose_yml and transfer_images


# ########## usage:

if [ $# -lt 2 ]; then 
  cat <<ENDOFFILE
anw env cmd args...
  env   reads environment variables from $ENVSDIR/{env}.sh
  cmd   is a command defined in the $0 script (list them with '$0 - help')
  args  are cmd-dependent arguments, most often none.
  Install script, see README.md for a description.
  Will read the files 
    ${MYENV_ENV} and $ENVSDIR/{env}
  and use the settings therein to generate the following files on the fly:
    $DOCKER_COMPOSE_YML  (which configures docker)
    $DOCKERENV_ENV  (used to hand environment into the docker containers)
    $TRAEFIK_YML  (for deploymodes LETSENCRYPT and CERTS only)
  There is no error handling, so be careful what you do.
ENDOFFILE
  exit 1
fi

# ########## individual command functions (externally visible):

help()   # args: 
{
  echo "########## anw commands:"
  egrep '\(\) *[#] args:' $0 | sed 's/() *[#] args:/ /'  # (must not match itself)
  cat <<ENDOFFILE
  ## Abbreviations:
  dc      docker-compose
ENDOFFILE
}

prepare_envs()   # args:   (step 1)
{
  announce $FUNCNAME
  mkdir -p $ENVSDIR
  cp -u $ENVSSRCDIR/myenv-template.env $ENVSDIR/myenv.env
  cp -u $ENVSSRCDIR/production-template.sh $ENVSDIR/production.sh
}

docker_login()   # args:   (step 2)
{
  announce $FUNCNAME
  docker login -u ${REGISTRYUSER} ${REGISTRY}
  if [ ! $REMOTE ]; then
    ssh -t $TUTH docker login -u ${REGISTRYUSER} ${REGISTRY}
  fi
}

install()   # args:        (step 3, the rest are substeps:)
{
  announce $FUNCNAME
  build_images
  transfer_env
  if [ $REMOTE ]; then
    push_images
    $onserver_anw onserver_pull_images
    $onserver_anw server_up
  else
    server_up
  fi
}

build_images()   # args: 
{
  announce $FUNCNAME
  create_files_on_the_fly
  docker-compose build
}

transfer_env()   # args: 
{
  announce $FUNCNAME
  rsync -av --relative anw.sh $DOCKER_COMPOSE_YML $DOCKERENV_ENV $THE_ENV  $TUTH:$ANW
}

push_images()   # args: 
{
  announce $FUNCNAME
  push_image django
  push_image postgres
  if [ $DEPLOYMODE != GUNICORN ]; then
    push_image traefik
  fi
}

push_image()   # args: servicename
{
	docker tag ${untagged}_$1 ${tagged}_$1
	docker push ${tagged}_$1
	docker rmi ${tagged}_$1  # remove tag to avoid cluttering the image list
}

onserver_pull_images()
{
  announce $FUNCNAME
  onserver_pull_image django
  onserver_pull_image postgres
  if [ $DEPLOYMODE != GUNICORN ]; then
    onserver_pull_image traefik
  fi
}

onserver_pull_image()   # args: servicename
{
	docker pull ${tagged}_$1
	docker tag ${tagged}_$1 ${untagged}_$1
	docker rmi ${tagged}_$1  # remove tag to avoid cluttering the image list
}

server_up()   # args: 
{
  announce $FUNCNAME
  docker-compose up -d
}

server_down()   # args: 
{
  announce $FUNCNAME
  docker-compose down
}


# ########## individual command functions (internal):

announce()  # internal
{
  echo ""
  echo "########## $1"
}

create_files_on_the_fly()   # internal
{
  make_dockerenv_env
  make_docker_compose_yml
  if [ $DEPLOYMODE != GUNICORN ]; then
    make_traefik_yml
  fi
}

make_docker_compose_yml()  # internal
{
  # ugly function due to inline documents violating the indentation
  announce $FUNCNAME
  cat >$DOCKER_COMPOSE_YML <<ENDOFFILE1
version: '2'
# https://docs.docker.com/compose/compose-file/

services:
  django:
    build:
      context: .
      dockerfile: ./compose/production/django/Dockerfile
    image: anw_${ENV_SHORTNAME}_django
    env_file: $DOCKERENV_ENV
    volumes:
      - ${VOLUME_SERVERDIR_DJANGO_LOG}:/djangolog:Z
    depends_on:
      - postgres
ENDOFFILE1
  if [ $DEPLOYMODE == GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE2
    ports:
      - "0.0.0.0:${GUNICORN_PORT}:5000"
ENDOFFILE2
  fi
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE3
    command: /start

  postgres:
    build:
      context: .
      dockerfile: ./compose/production/postgres/Dockerfile
    image: anw_${ENV_SHORTNAME}_postgres
    env_file: $DOCKERENV_ENV
    volumes:
      - ${VOLUME_SERVERDIR_POSTGRES_DATA}:/var/lib/postgresql/data:Z
      - ${VOLUME_SERVERDIR_POSTGRES_BACKUP}:/backups:z

ENDOFFILE3
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE4
  traefik:
    build:
      context: .
      dockerfile: ./compose/production/traefik/Dockerfile
    image: anw_${ENV_SHORTNAME}_traefik
    env_file: $DOCKERENV_ENV
    depends_on:
      - django
    volumes:
ENDOFFILE4
   fi
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE5
      - ${VOLUME_SERVERDIR_TRAEFIK_ACME}:/etc/traefik/acme:z
ENDOFFILE5
  fi
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE6
      - ${VOLUME_SERVERDIR_TRAEFIK_SSL}:/etc/traefik/myssl:z
ENDOFFILE6
  fi
  if [ $DEPLOYMODE != GUNICORN ]; then
    cat >>$DOCKER_COMPOSE_YML <<ENDOFFILE7
    ports:
      - "0.0.0.0:${TRAEFIK_HTTP_PORT}:80"
      - "0.0.0.0:${TRAEFIK_HTTPS_PORT}:443"
ENDOFFILE7
  fi
}  # END make_docker_compose_yml

make_dockerenv_env()  # internal
{
  announce $FUNCNAME
  python3 $PATCHENV $MYENV_ENV $DOCKERENV_ENV
}

make_traefik_yml()  # internal
{
  # ugly function due to inline documents violating the indentation
  announce $FUNCNAME
  cat >$TRAEFIK_YML <<ENDOFFILE1
# https://doc.traefik.io/traefik/v2.0/providers/file/
# Quote: "Go Templating only works with dedicated dynamic configuration files.
#         Templating does not work in the Traefik main static configuration file."
log:
  level: INFO

entryPoints:
  web:
    # http
    address: ":80"

  web-secure:
    # https
    address: ":443"

ENDOFFILE1
  if [ $DEPLOYMODE == LETSENCRYPT ]; then
      cat >>$TRAEFIK_YML <<ENDOFFILE2
certificatesResolvers:
  letsencrypt:
    # https://docs.traefik.io/master/https/acme/#lets-encrypt
    acme:
      email: "techexpert@here-at-example.com"
      storage: /etc/traefik/acme/acme.json
      # https://docs.traefik.io/master/https/acme/#httpchallenge
      httpChallenge:
        entryPoint: web
ENDOFFILE2
  fi
  cat >>$TRAEFIK_YML <<ENDOFFILE3
http:
  routers:
    web-router:
      rule: "PathPrefix(`/`)"
      entryPoints:
        - web
      middlewares:
        - redirect_root
        - redirect_a
        - redirect_fu
        - redirect_to_https
      service: django

    web-secure-router:
      # https://doc.traefik.io/traefik/routing/routers/#rule
      rule: "PathPrefix(`/`)"
      entryPoints:
        - web-secure
      # middlewares:
      #   - csrf
      service: django
      tls: {}

  middlewares:
    # https://doc.traefik.io/traefik/master/middlewares/overview/
    redirect_root:
      # https://doc.traefik.io/traefik/v2.0/middlewares/redirectregex/
      redirectRegex:
        regex: "^http://a.nwesen.de/?$"
        replacement: "http://anwesende.imp.fu-berlin.de/"
    redirect_a:
      redirectRegex:
        regex: "^http://a.nwesen.de/a/(.*)$"
        replacement: "http://anwesende.imp.fu-berlin.de/${1}"
    redirect_fu:
      redirectRegex:
        regex: "^http://a.nwesen.de/fu/(.*)$"
        replacement: "http://anwesende.imp.fu-berlin.de/${1}"
    redirect_to_https:
      # https://docs.traefik.io/master/middlewares/redirectscheme/
      redirectScheme:
        scheme: https
        permanent: false

  services:
    django:
      loadBalancer:
        servers:
          - url: http://django:5000
ENDOFFILE3
  if [ $DEPLOYMODE == LETSENCRYPT ]; then
    cat >>$TRAEFIK_YML <<ENDOFFILE4
tls:
  # https://docs.traefik.io/master/routing/routers/#certresolver
  certResolver: letsencrypt
ENDOFFILE4
  fi
  if [ $DEPLOYMODE == CERTS ]; then
    cat >>$TRAEFIK_YML <<ENDOFFILE5
tls:
  # https://docs.traefik.io/master/routing/routers/#certresolver
  certificates:
    - certFile: /etc/traefik/myssl/anwesende.pem
      keyFile: /etc/traefik/myssl/anwesende-key.pem
ENDOFFILE5
  fi
  cat >>$TRAEFIK_YML <<ENDOFFILE6
  options:
    default:
      minVersion: VersionTLS12
      cipherSuites:
        # https://ssl-config.mozilla.org/#server=traefik&version=2.1.2&config=intermediate&guideline=5.6
        # https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices#25-use-forward-secrecy
        - "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"
        - "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"
        - "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305"
        - "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
        - "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
        - "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305"

providers:
  # https://docs.traefik.io/master/providers/file/
  file:
    filename: /etc/traefik/traefik.yml
    watch: true

ENDOFFILE6
}  # END make_traefik_yml

ssh_th()  # internal, assumes env has been read already
{
  command="ssh $TUTH $*"
  echo $command
  $command
}

# ########## MAIN:

set -o xtrace  # -x
set -o errexit  # -e
which_env=$1
cmd=$2
shift 2

cd -P -- "$(dirname -- "$0")"  # cd to script dir if called from elsewhere (ssh!)

if [ $which_env != '-' -o $which_env != '--' ]; then
  set -o allexport  # -a: export all new shell variables
  source $ENVSDIR/$which_env.sh
  THE_ENV=$ENVSDIR/${which_env}.sh
  set +o allexport
  untagged=${ANW}_${ENV_SHORTNAME}
  tagged=${REGISTRYPREFIX}/${ANW}_${ENV_SHORTNAME}
fi

announce "Environment is \'$which_env\'"
$cmd
